<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<script>
  class MPromise{
    static PENDING ='pending'
    static FULFILED = 'fulfilled'
    static REJECTED = 'rejected'
    constructor(func){
      this.promiseState = MPromise.PENDING
      this.promiseResult = null
      this.onFulfiledCallback = []
      this.onRejectedCallback = []
      try{
        func(this.resolve.bind(this),this.reject.bind(this))
      }catch(e){
        this.reject(e)
      }
    }
  //   const p1  = new MPromise((resolve,reject)=>{
  //   setTimeout(()=>{
  //     resolve(2)
  //     console.log(4)
  //   }) 
  // })
    resolve(result){
      setTimeout(()=>{
      if(this.promiseState === MPromise.PENDING){  
          this.promiseState = MPromise.FULFILED
          this.promiseResult = result
          this.onFulfiledCallback.forEach(callback=>{
            callback(result)
          })
      }
    })
    }
    reject(reason){
      setTimeout(()=>{
      if(this.promiseState === MPromise.PENDING){
          this.promiseState = MPromise.REJECTED
          this.promiseResult = reason
          this.onRejectedCallback.forEach(callback=>{
            callback(reason)
          })
      }
    })
    }
    then(onFulfiled,onRejected){
      onFulfiled = typeof onFulfiled === 'function'? onFulfiled: value =>value
      onRejected = typeof onRejected === 'function'? onRejected: reason =>{
        throw reason 
      }
      const promise2 = new MPromise((resolve,reject)=>{
        if(this.promiseState === MPromise.FULFILED){
          setTimeout(()=>{
            try{
              let x = onFulfiled(this.promiseResult)
              resolvePromise(promise2,x,resolve,reject)
            }catch(e){
              reject(e)
            }
          })
        }
        if(this.promiseState === MPromise.REJECTED){
          setTimeout(()=>{
            try{
              let x = onRejected(this.promiseResult)
              resolvePromise(promise2,x,resolve,reject)
            }catch(e){
              reject(e)
            }
          })
        }
        else if(this.promiseState === MPromise.PENDING){
          this.onFulfiledCallback.push(()=>{
            setTimeout(()=>{
              try{
                let x = onFulfiled(this.promiseResult)
                resolvePromise(promise2,x,resolve,reject)
              }catch(e){
                reject(e)
              }
            })
          })
          this.onRejectedCallback.push(()=>{
            setTimeout(()=>{
              try{
                let x = onRejected(this.promiseResult)
                resolvePromise(promise2,x,resolve,reject)
              }catch(e){
                reject(e)
              }
            })
          })
        }
      })
      return promise2
    }
    static resolve(value){
      if(value instanceof MPromise){
        return value
      }else if(value instanceof Object&& 'then' in value){
        return new MPromise((resolve,reject)=>{
          value.then(resolve,reject)
        })
      }else{
        return new MPromise((resolve,reject)=>{
          resolve(value)
        })
      }
    }
    static reject(value){
      return new MPromise((resolve,reject)=>{
        reject(value)
      })
    }
    catch(onRejected){
      return this.then(undefined,onRejected)
    }
    finally(callBack){
      return this.then(callBack,callBack)
    }
    static all(promises){
      return new Promise((resolve,reject)=>{
        if(Array.isArray(promises)){
          const reuslt = []
          let count = 0
          if(promises.length===0){
            return resolve(promises)
          }
          promises.forEach((p,i)=>{
            if(p instanceof MPromise){
              MPromise.resolve(p).then(value=>{
                count++;
                result[i]=value;
                count===promises.length&&resolve(result)
              },reason=>{
                reject(reason)
              })
            }
          })
        }else{
          return reject(new TypeError('Argument is not iterable'))
        }
      })
    }
    static allSettled(promises){
      return new Promise((resolve,reject)=>{
        if(Array.isArray(promises)){
          const reuslt = []
          let count = 0
          if(promises.length===0){
            return resolve(promises)
          }
          promises.forEach((p,i)=>{
            if(p instanceof MPromise){
              MPromise.resolve(p).then(value=>{
                count++;
                result[i]={
                  status:'fulfilled',
                  value
                };
                count===promises.length&&resolve(result)
              },reason=>{
                count++;
                result[i]={
                  status:'rejected',
                  value
                };
                count===promises.length&&resolve(result)
              })
            }
          })
        }else{
          return reject(new TypeError('Argument is not iterable'))
        }
      })
    }
    static any(promises){
      return new Promise((resolve,reject)=>{
        if(Array.isArray(promises)){
          const reuslt = []
          let count = 0
          if(promises.length===0){
            return reject(new AggregateError('All promises were rejected'))
          }
          promises.forEach((p,i)=>{
            if(p instanceof MPromise){
              MPromise.resolve(p).then(value=>{
                resolve(value)
              },reason=>{
                count++;
                result[i]=reason;
                count===promises.length&&reject(new AggregateError(errors))
              })
            }
          })
        }else{
          return reject(new TypeError('Argument is not iterable'))
        }
      })
    }
    static race(promises){
      return new Promise((resolve,reject)=>{
        if(Array.isArray(promises)){
          if(promises.length>0){
            promises.forEach(i=>{
              MPromise.resolve(i).then(resolve,rejec)
            })
          }
        }else {
            return reject(new TypeError('Argument is not iterable'))
        }
      })
    }
  }
  function resolvePromise(promise2,x,resolve,reject){
    if(promise2===x){
      return reject(new TypeError('Chaining cycle detected for promise'))
    }
    if(x instanceof MPromise){
      if(x.promiseState === MPromise.PENDING ){
        x.then(y=>resolvePromise(promise2,y,resolve,reject),reject)
      }else if (x.promiseState === MPromise.FULFILED){
        resolve(x.promiseResult)
      }else if (x.promiseState === MPromise.REJECTED){
        reject(x.promiseResult)
      }
    }else if (x!==null&&((typeof x ==='object')||(typeof x ==='funciton'))){
      try{
        const then = x.then
      }catch(e){
         reject(e)
      }
      if(typeof then === 'function'){
        let called = false;
       try{
        then.call(x,
        y=>{
          if(called){
            return
          }
          called = true
          resolvePromise(promise2,y,resolve,reject)
        },
        r=>{
          if(called){
            return
          }
          called = true
          reject(r)
        })
       }catch(e){
        if(called){
            return
          }
          called = true
          reject(e)
       }
      }else{
        resolve(x)
      }
    }else {
      return resolve(x)
    }
  }
  console.log(1)
  const p1  = new MPromise((resolve,reject)=>{
    // setTimeout(()=>{
    //   resolve(2)
    //   console.log(4)
    // }) 
    resolve(2)
    reject(4)
    console.log(3)
  })
  
  p1.then((result)=>{
    console.log(result)
  },(reject)=>{
    console.log(reject)
  })
  console.log(5)
</script>
<body>
  
</body>
</html>